[{"categories":["技术文档"],"content":"wsl 在wsl的/etc/wsl.conf文件中加入如下内容 [interop] appendWindowsPath = false [automount] enabled = false 理论上可以关闭与windows的交互，但是由于wsl共享了windows的网络，所以无法真正禁止磁盘挂载。 可以修改updatedb的搜索范围来减小磁盘挂载的影响，编辑 /etc/updatedb.conf的方法并不是对所有发行版全部适用，可以在.zshrc或者.bashrc中加入如下内容 alias updatedb=\"sudo updatedb --prunepaths=\\\"/mnt/c /mnt/d\\\"\" 以后只需要执行updatedb就行了 ","date":"2025-03-08","objectID":"/posts/b9c4490/:1:0","tags":["wsl","linux","windows"],"title":"Wsl","uri":"/posts/b9c4490/"},{"categories":["技术文档"],"content":"升级glibc 警告 GLIBC 是系统的核心库，升级不当可能导致系统无法启动，最好先在docker中测试 参考链接 https://stone.moe/posts/%E6%95%99%E7%A8%8B/how-to-upgrade-linux-glibc-manually/ https://www.cnblogs.com/KBin/articles/Upgrade-GLIBC-for-Linux.html ","date":"2025-03-04","objectID":"/posts/bc711ee/:1:0","tags":["glibc","linux","升级"],"title":"升级glibc","uri":"/posts/bc711ee/"},{"categories":["技术文档"],"content":"1. 查看版本 ldd --version 或者使用 strings /usr/lib/x86_64-linux-gnu/libc.so.6 |grep GLIBC ","date":"2025-03-04","objectID":"/posts/bc711ee/:2:0","tags":["glibc","linux","升级"],"title":"升级glibc","uri":"/posts/bc711ee/"},{"categories":["技术文档"],"content":"2. 下载指定版本 进入清华源下载相应版本 https://mirror.tuna.tsinghua.edu.cn/gnu/glibc wget https://mirror.tuna.tsinghua.edu.cn/gnu/glibc/glibc-2.40.tar.gz 解压文件进入目录,我下载的是glibc-2.40,版本因人而异 tar -xzf glibc-2.40.tar.gz cd glibc-2.40 创建一个用于编译glib的目录： mkdir build \u0026\u0026 cd build 安装依赖 sudo apt-get install libc6-dev-i386 配置编译选项： .../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin 开始编译 make -j8 最后，安装glib： sudo make install ","date":"2025-03-04","objectID":"/posts/bc711ee/:3:0","tags":["glibc","linux","升级"],"title":"升级glibc","uri":"/posts/bc711ee/"},{"categories":["技术文档"],"content":"3. 设置软链接 查看系统gcc/g++版本 sudo updatedb --prunepaths=\"/mnt\" locate g++|grep /usr/bin/ locate gcc|grep /usr/bin/ 设置软链接的优先级 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 10 sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-14.1.0/bin/gcc 20 sudo update-alternatives --install /usr/bin/g++ g++ /opt/gcc-14.1.0/bin/g++ 20 手动切换gcc与g++版本 sudo update-alternatives --config gcc sudo update-alternatives --config g++ ","date":"2025-03-04","objectID":"/posts/bc711ee/:4:0","tags":["glibc","linux","升级"],"title":"升级glibc","uri":"/posts/bc711ee/"},{"categories":["技术文档"],"content":"4. 更新系统libstdc++版本 libstdc++是适应于g++的标准库,位于/usr/lib/x86_64-linux-gnu/下面 使用指令先看下系统目前都有哪些版本的 strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 寻找安装高版本gcc目录下的libstdc++.so.6 sudo find /opt -name \"libstdc++.so.6*\" 使用之前的指令看看其是否包含需要的版本 strings /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 | grep GLIBCXX 将文件复制到指定目录并建立新的链接 # 复制 sudo cp /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/ # 删除之前链接 sudo unlink /usr/lib/x86_64-linux-gnu/libstdc++.so.6 # 创建新的链接 sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/libstdc++.so.6 ","date":"2025-03-04","objectID":"/posts/bc711ee/:5:0","tags":["glibc","linux","升级"],"title":"升级glibc","uri":"/posts/bc711ee/"},{"categories":["技术文档"],"content":"终端美化 ","date":"2025-02-22","objectID":"/posts/17f286e/:1:0","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1. zsh ","date":"2025-02-22","objectID":"/posts/17f286e/:2:0","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.1 安装zsh sudo apt-get update sudo apt-get install zsh #设为默认 chsh -s $(which zsh) 不要关闭终端 ","date":"2025-02-22","objectID":"/posts/17f286e/:2:1","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.2 安装oh-my-zsh 1、curl/wget下载 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 2、手动下载 git clone git@github.com:ohmyzsh/ohmyzsh.git cd ohmyzsh/tools/ ./install.sh ","date":"2025-02-22","objectID":"/posts/17f286e/:2:2","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.3 修改主题 vim ~/.zshrc 找到ZSH_THEME=“”，这句话，在双引号里面写上 crunch就可以啦 ","date":"2025-02-22","objectID":"/posts/17f286e/:2:3","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.4 修改远程仓库地址 HTTPS访问GitHub经常受到网络限制或防火墙的影响，改用SSH是一个更稳定的选择 打开配置文件： vim ~/.oh-my-zsh/.git/config 将仓库 URL 从 HTTPS 改为 SSH 格式： remote \"origin\"] url = git@github.com:ohmyzsh/ohmyzsh.git fetch = +refs/heads/*:refs/remotes/origin/* ","date":"2025-02-22","objectID":"/posts/17f286e/:2:4","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.5 设置插件 zsh-autosuggestions：历史补全 下载安装 git clone git@github.com:zsh-users/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions vim ~/.zshrc进去配置zsh-autosuggestions plugins=( git # other plugins... zsh-autosuggestions ) ","date":"2025-02-22","objectID":"/posts/17f286e/:2:5","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"1.6 终端美化 打开JSON设置，定位到Defaults里添加： 使用亚克力效果： \"useAcrylic\": true, \"opacity\": 80 设置背景： \"backgroundImage\": \"C:/Users/lwb/Desktop/picture/yourname.jpg\", \"backgroundImageOpacity\": 0.4 ","date":"2025-02-22","objectID":"/posts/17f286e/:2:6","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"2. oh my posh 安装参考官方文档 https://ohmyposh.dev/docs/installation/linux 设置主题 vim ~/.zshrc 添加如下语句 export PATH=\"$HOME/.local/bin:$PATH\" # 想使用windows系统上的主题可以加入 eval \"$(oh-my-posh --init --shell zsh --config /mnt/c/Users/lwb/AppData/Local/Programs/oh-my-posh/themes/M365Princess.json)\" # 想使用本系统上的主题可以加入 eval \"$(oh-my-posh --init --shell zsh --config /home/lwb/.cache/oh-my-posh/themes/M365Princess.json)\" home目录下conda版本不生效：在主题文件中将python segment的\"home_enabled\"设置为true { \"type\": \"python\", ... \"properties\": { \"home_enabled\": true, ... }, ... }, ","date":"2025-02-22","objectID":"/posts/17f286e/:3:0","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["技术文档"],"content":"3. git bash 删除键窗口会闪烁:新建一个~/.inputrc 文件，输入set bell-style none，保存； ","date":"2025-02-22","objectID":"/posts/17f286e/:4:0","tags":["终端"],"title":"终端美化","uri":"/posts/17f286e/"},{"categories":["笔记"],"content":"C++初始化 ","date":"2025-02-18","objectID":"/posts/be00f5e/:1:0","tags":["c++","初始化"],"title":"C++初始化","uri":"/posts/be00f5e/"},{"categories":["笔记"],"content":"1. 列表初始化 初始化列表用{}表示，正常是没有类型的，但是在函数的参数列表中可以用std::initializer_list表示能够接收初始化列表。 std::initializer_list在一下情况会自动构造对象: 用于列表初始化对象，并且构造函数需要能够接受std::initializer_list参数 用于赋值或者函数调用，并且赋值运算符/函数需要能够接受std::initializer_list参数 绑定到auto或者包括在范围 for 循环中 注意 auto p = { 1,2,3 };//能够推导出类型为std::initializer_lis auto p2 { 1,2,3 };//无法推导 ","date":"2025-02-18","objectID":"/posts/be00f5e/:2:0","tags":["c++","初始化"],"title":"C++初始化","uri":"/posts/be00f5e/"},{"categories":["笔记"],"content":"C++代码书写规范 变量命名使用下划线命名法，函数命名使用大驼峰命名法，类和结构体使用大驼峰命名法，文件名使用下划线命名法 全局变量和常量使用k+大驼峰命名法，类成员变量可以以下划线作为结尾，结构体成员变量不加下划线 尽量不要使用全局变量，可以将其封装进对象里 ros中回调函数的形参可以使用const name \u0026 修饰 函数声明中const修饰符无意义，只需在函数定义中使用 在成员函数中使用ros中的subscribe需要参考以下格式：省略.subscribe(“话题”, 1, \u0026类::回调函数, this); 模板类的静态成员变量是每个特定实例化类型共享一份，而不是所有实例化类共享同一份。例如MyClass\u003cint\u003e和MyClass\u003cdouble\u003e的静态成员变量是独立的。 ","date":"2025-02-17","objectID":"/posts/5ad53d5/:1:0","tags":["C++","代码规范"],"title":"C++代码书写规范","uri":"/posts/5ad53d5/"},{"categories":["技术文档"],"content":"Tmux ","date":"2025-02-16","objectID":"/posts/51dfcde/:1:0","tags":["tmux","linux"],"title":"Tmux","uri":"/posts/51dfcde/"},{"categories":["技术文档"],"content":"1. 安装 git clone git@github.com:tmux/tmux.git cd tmux sh autogen.sh ./configure \u0026\u0026 make ","date":"2025-02-16","objectID":"/posts/51dfcde/:2:0","tags":["tmux","linux"],"title":"Tmux","uri":"/posts/51dfcde/"},{"categories":["技术文档"],"content":"2. 配置 再配合zsh使用时会出现提示代码为白色的现象，需要修改~/目录下的.tmux.conf set -g default-terminal \"tmux-256color\" 为了让tmux支持鼠标操作，需要继续加入内容 set-option -g mouse on ","date":"2025-02-16","objectID":"/posts/51dfcde/:3:0","tags":["tmux","linux"],"title":"Tmux","uri":"/posts/51dfcde/"},{"categories":["技术文档"],"content":"3. 使用 tmux的使用可参考： burlingame Blog https://www.cnblogs.com/zhiminyu/p/17457933.html ","date":"2025-02-16","objectID":"/posts/51dfcde/:4:0","tags":["tmux","linux"],"title":"Tmux","uri":"/posts/51dfcde/"},{"categories":["笔记"],"content":"STL容器 ","date":"2025-02-15","objectID":"/posts/10a4e19/:1:0","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"1. Array ","date":"2025-02-15","objectID":"/posts/10a4e19/:2:0","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"1.1 初始化 std::array无构造函数，只含有非静态公共成员变量，所以属于聚合类型，其他聚合类型还有数组类型。 对聚合体使用列表初始化被称为聚合初始化，它也是列表初始化的一种形式，聚合体初始化需要层层嵌套。 std::array的定义大概如下： template\u003ctypename T, std::size_t N\u003e class array { public: T _data[N]; }; 它的聚合初始化如下： /** * 第一层是为了初始化std::array本身 * 第二层是为了初始化里面的数组 */ std::array\u003cint, 3\u003e arr{{1,2,3}}; 由于 C++ 聚合初始化时允许省略所有的内部花括号，所以可以简写做： std::array\u003cint, 3\u003e arr{1,2,3}; 对于二维数组。标准形式的初始化如下： /** * 最外两层是为了初始化外层array * 内部两层是为了初始化内层array */ std::array\u003cstd::array\u003cint, 4\u003e, 3\u003e a{{ {{1, 2, 3, 4}}, {{5, 6, 7, 8}}, {{9, 10, 11, 12}} }}; 因为子数组内不再出现内部花括号，所以可以让子数组采用省略语法： /** * 最外两层是为了初始化外层array * 内部一层是省略后的写法 */ std::array\u003cstd::array\u003cint, 4\u003e, 3\u003e a{{ {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} }}; ","date":"2025-02-15","objectID":"/posts/10a4e19/:2:1","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"2. Vector ","date":"2025-02-15","objectID":"/posts/10a4e19/:3:0","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"2.1 赋值 在将其他容器的数值赋值给std::vector时，有两种方式，分别是通过构造函数或assign方法和使用std::copy算法。使用构造函数和assign会自动管理内存和大小，无需使用resize手动预留空间；使用std::copy算法需要先分配空间 #include \u003carray\u003e #include \u003cvector\u003e int main() { std::array\u003cint, 5\u003e arr = {1, 2, 3, 4, 5}; // 方法1: 通过构造函数初始化 std::vector\u003cint\u003e vec1(arr.begin(), arr.end()); // 方法2: 通过assign方法赋值 std::vector\u003cint\u003e vec2; vec2.assign(arr.begin(), arr.end()); return 0; } #include \u003carray\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e // 需要包含 algorithm 头文件 int main() { std::array\u003cint, 5\u003e arr = {1, 2, 3, 4, 5}; std::vector\u003cint\u003e vec; // 确保 vector 有足够空间（可选，但建议提前预留） vec.resize(arr.size()); // 使用 std::copy std::copy(arr.begin(), arr.end(), vec.begin()); return 0; } ","date":"2025-02-15","objectID":"/posts/10a4e19/:3:1","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"2.2 增添元素 std::vector可以使用push_back()方法在末尾添加元素，也可以使用emplace_pack()方法在末尾添加元素。二者的差别如下: emplace_back()方法是成员函数模板，它根据传入的变量来推导类型；push_back()方法只是使用了类模板std::vector的类型模板形参，使用时已经实例化了对象，参数类型是确定的。 emplace_back()方法可以接受构造函数的参数，而push_back()方法只能接受一个参数，因为参数类型是确定的。 当emplace_back()接收参数时可以直接在目标内存中直接构造对象，即原位构造。比生成副本后移动性能更好。 注意 初始化器列表不参与模板参数推导，对emplace_back()传入{}时会报错。但是push_back()不是函数模板，不需要推导类型，不会报错 注意 当参数类型和容器数据类型一致时，二者都会调用拷贝构造函数或者移动构造函数，二者没有区别 ","date":"2025-02-15","objectID":"/posts/10a4e19/:4:0","tags":["C++","STL"],"title":"STL容器","uri":"/posts/10a4e19/"},{"categories":["笔记"],"content":"左值引用与右值引用 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:1:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1. 左值与右值 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1.1 左值 左值是可以取地址的对象，比如变量名和解引用的指针变量。 // 以下的a、p、*p、b都是左值 int a = 3; int* p = \u0026a; *p; const int b = 2; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"1.2 右值 右值是不能取地址的对象，比如常量、临时变量、函数返回值、运算符返回值等。 double x = 1.3, y = 3.8; // 以下几个都是常见的右值 10; // 字面常量 x + y; // 表达式返回值 fmin(x, y); // 传值返回函数的返回值 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:2:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2. 左值引用与右值引用 无论左值引用还是右值引用，都是给对象取别名。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.1 左值引用 是指对左值的引用，作用是避免对象拷贝。 int\u0026 ra = a; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.2 右值引用 是指对右值的引用，作用是延长对象的生命周期。 int\u0026\u0026 rr = 10; ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"2.3 对比与总结 左值引用可以指向左值，在指向右值时需要const修饰 右值引用可以指向右值，在指向左值时需要std::move() const int\u0026 rt4 = 8; // 临时对象的生命周期会被延长至引用的作用域结束 int t = 10; int\u0026\u0026 rrt = std::move(t); ","date":"2025-02-08","objectID":"/posts/1f15d8a/:3:3","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3. 左值引用的实际意义 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3.1 实际意义 传值传参和传值返回都会产生拷贝，而左值引用可以减少拷贝，从而提高效率。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"3.2 短板 但当局部对象出了函数作用域以后就不存在了，所以不可以使用左值引用返回了。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:4:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4. 右值引用的实际意义 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:0","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.1 实际意义 解决函数参数的传递中（针对返回的将亡值）传递效率和空间不如意的问题。 在拷贝构造和拷贝赋值中，对左值使用move+右值引用可以将深拷贝转为浅拷贝。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:1","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.2 短板 左值经过move()后，会失去原来的地址，所以无法再用之前的变量名访问。 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:2","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["笔记"],"content":"4.3 完美转发 函数模板（不是类模板）中的\u0026\u0026不表示右值引用，而是万能引用，模板类型必须通过推断才能确定，其接收左值后会被推导为左值引用，接收右值后会被推导为右值引用。 void Func(int\u0026 x) { cout \u003c\u003c \"左值引用\" \u003c\u003c endl; } void Func(int\u0026\u0026 x) { cout \u003c\u003c \"右值引用\" \u003c\u003c endl; } template\u003ctypename T\u003e void f(T\u0026\u0026 t) // 万能引用 { Func(t); // 根据参数t的类型去匹配合适的重载函数 } 注意 右值引用后便失去了右值的属性。 f(10); 10是右值，传参后万能引用被推导为右值引用，但在f()函数中它变为了左值，因此实际调用的函数是void Func(int\u0026 x)。 为了实现完美转发，除了使用万能引用之外，我们还要用到std::forward（C++11），它在传参的过程中保留对象的原生类型属性。 void Func(int\u0026 x) { cout \u003c\u003c \"左值引用\" \u003c\u003c endl; } void Func(int\u0026\u0026 x) { cout \u003c\u003c \"右值引用\" \u003c\u003c endl; } template\u003ctypename T\u003e void f(T\u0026\u0026 t) // 万能引用 { Func(std::forward\u003cT\u003e(t)); // 根据参数t的类型去匹配合适的重载函数 } int main() { PerfectForward(10); // 仍是右值引用 return 0; } 注意 实现完美转发需要用到万能引用和 std::forward。 本笔记参考了「Hoshino373」的文章，原文链接为：https://blog.csdn.net/m0_59938453/article/details/125858335 ","date":"2025-02-08","objectID":"/posts/1f15d8a/:5:3","tags":["C++"],"title":"C++引用","uri":"/posts/1f15d8a/"},{"categories":["技术文档"],"content":"升级Eigen库 usr/include/eigen3存放的是apt安装的Eigen库 /usr/local/include/eigen3存放的是源码安装的Eigen库 ","date":"2025-02-05","objectID":"/posts/0d48d55/:1:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"1. 查看Eigen版本 sudo updatedb locate Macros.h|grep eigen3 gedit (相应位置)/usr/include/eigen3/Eigen/src/Core/util/Macros.h ","date":"2025-02-05","objectID":"/posts/0d48d55/:2:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"2. 安装 # 下载Eigen源码,最好下载最新release版本 wget https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.gz # 解压 mkdir eigen-3.4.0 tar -zxvf eigen-3.4.0.tar.gz -C ./eigen-3.4.0 #编译安装 mkdir build \u0026\u0026 cd build cmake .. sudo make install 只需将eigen文件复制到本地调用文件夹中就能完成对apt安装的覆盖 /usr/include sudo cp -r /usr/local/include/eigen3 /usr/include ","date":"2025-02-05","objectID":"/posts/0d48d55/:3:0","tags":["Eigen","linux"],"title":"升级Eigen库","uri":"/posts/0d48d55/"},{"categories":["技术文档"],"content":"在Linux上使用v2ray ","date":"2025-02-05","objectID":"/posts/b535a54/:1:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1. 安装 v2ray-core 和 v2rayA ","date":"2025-02-05","objectID":"/posts/b535a54/:2:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1.1 安装v2ray-core 参考网站：检测到 geosite.dat, geoip.dat 文件或 v2ray-core 可能未正确安装 – 爱思考的人 (aisikao.ren) v2ray-core:https://github.com/v2fly/v2ray-core 可以在上面任何一个网趾下载安装文件，下载的时候需要注意你的 CPU 架构，下载好之后解开压缩包，然后把可执行文件复制到 /usr/local/bin/ 或 /usr/bin/（推荐前者），把几个 dat 格式的文件复制到 /usr/local/share/v2ray/ 或者 /usr/share/v2ray/（推荐前者，xray 用户记得把文件放到 xray 文件夹），最后授予 v2ray/xray 可执行权限。 以下是用 bash 命令操作的示例： ## 注意要根据 CPU 架构安装不同版本 wget https://github.com/v2fly/v2ray-core/releases/latest/download/v2ray-linux-64.zip unzip v2ray-linux-64.zip -d ./v2ray sudo mkdir -p /usr/local/share/v2ray sudo cp ./v2ray/*dat /usr/local/share/v2ray sudo install -Dm755 ./v2ray/v2ray /usr/local/bin/v2ray ","date":"2025-02-05","objectID":"/posts/b535a54/:2:1","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"1.2 安装v2rayA 参考网站介绍 - v2rayA ## 注意要根据 CPU 架构安装不同版本 wget https://github.com/v2rayA/v2rayA/releases/latest/download/v2rayA/v2rayA/releases sudo apt install /path/download/installer_debian_xxx_vxxx.deb ### 自行替换 deb 包所在的实际路径 启动 v2rayA sudo systemctl start v2raya.service 设置开机自动启动 sudo systemctl enable v2raya.service ","date":"2025-02-05","objectID":"/posts/b535a54/:2:2","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"2. 使用 如果你通过 2017 端口 如 http://localhost:2017 无法访问 UI 界面，请检查你的服务是否已经启动。 在第一次进入页面时，你需要创建一个管理员账号，请妥善保管你的用户名密码，如果遗忘，使用sudo v2raya --reset-password命令重置。 设置 关闭IP转发和端口分享 透明代理/系统代理为启用:大陆白名单模式 透明代理/系统代理实现方式为tproxy 规则端口的分流模式为大陆白名单模式 防止DNS污染为关闭 特殊模式为关闭 TCPFastOpen为保持系统默认 多路复用为关闭 自动更新订阅为服务端启动时更新订阅 解析订阅链接/更新时优先使用为跟随透明代理/系统代理 ","date":"2025-02-05","objectID":"/posts/b535a54/:3:0","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["技术文档"],"content":"注意 关机前记得关闭服务，否则下次开机自动开启服务 ","date":"2025-02-05","objectID":"/posts/b535a54/:3:1","tags":["linux","v2ray"],"title":"在Linux上使用v2ray","uri":"/posts/b535a54/"},{"categories":["笔记"],"content":"docker命令 查看本地镜像 docker images 查看运行容器 docker ps 根据镜像创建容器 docker run --name my_container -dit --network=host my_image:tag /bin/bash --name：加上此参数可指定生成容器的名称，此参数位置在镜像id前 my_container 指定的容器名字 -d：打开后台运行 -i：打开控制台交互（不设置此选项退出容器后docker会自动清理未活动的容器） -t：支持终端登录 --network=host: 指定网络模式为主机网络 my_image:tag 是要使用的镜像名称和标签。不喜欢打这么多字的可以用id代替 /bin/bash 表示要在容器内启动 Bash Shell进行交互 进入容器正在执行的终端 docker attach 容器id # 如果使用exit退出，容器会停止运行 # 想退出容器但不想容器停止，则按住Ctrl+P+Q退出 进入容器并开启一个新的终端 docker exec -it 容器id /bin/bash # 如果使用exit退出，容器也不会停止 Docker容器向宿主机传送文件 docker cp container_id:\u003cdocker容器内的路径\u003e \u003c本地保存文件的路径\u003e 宿主机向Docker容器传送文件 docker cp 本地文件的路径 container_id:\u003cdocker容器内的路径\u003e ","date":"2025-02-05","objectID":"/posts/c41c58c/:1:0","tags":["docker","linux"],"title":"Docker","uri":"/posts/c41c58c/"},{"categories":["技术文档"],"content":"git ","date":"2025-02-05","objectID":"/posts/539f164/:1:0","tags":["git","linux","windows"],"title":"Git","uri":"/posts/539f164/"},{"categories":["技术文档"],"content":"1. ssh配置 创建本地密钥 cd ~/.ssh ssh-keygen -t rsa -b 4096 在~/.ssh添加文件config touch config vim config # 在里面添加 Host github.com User git IdentityFile ~/.ssh/mykey # 这里mykey换成你命名的私钥名称 ","date":"2025-02-05","objectID":"/posts/539f164/:2:0","tags":["git","linux","windows"],"title":"Git","uri":"/posts/539f164/"},{"categories":["技术文档"],"content":"2. 添加SSH key到github 拷贝 id_rsa.pub 文件的内容 vim ~/.ssh/id_rsa.pub 登录github账号，从右上角的设置进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key ","date":"2025-02-05","objectID":"/posts/539f164/:3:0","tags":["git","linux","windows"],"title":"Git","uri":"/posts/539f164/"},{"categories":["技术文档"],"content":"CLion上使用ros ","date":"2025-02-05","objectID":"/posts/d8e0057/:1:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"1. 启动CLion 在ROS的根目录下(执行catkin_make的目录)执行如下(如果已将该路径添加到.bashrc文件则可跳过)： source ./devel/setup.bash 寻找CLion位置 # 使用locate sudo updatedb locate clion.sh # 使用find sudo find / -name \"clion.sh\" 打开CLion(sh 后面的路径因人而异) sh /home/robot/.local/share/JetBrains/Toolbox/apps/clion-nova/bin/clion.sh ","date":"2025-02-05","objectID":"/posts/d8e0057/:2:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"2. CLion 中打开一个 ROS 项目 一定要选择工作区的 src 目录以从中导入项目 设置build路径 默认情况下，CLion 将生成输出放在自动创建的 cmake-build-debug 或 cmake-build-release 目录中。对于 ROS 开发，这意味着将在 CLion 和运行 catkin _ make 的控制台中使用两种不同的构建。因此需要将 CLion 构建路径设置为 catkin 工作区目录 将CMake options(CMake 选项) 项修改如下，PATH后面是自己ROS的devel目录 -DCATKIN_DEVEL_PREFIX:PATH=/home/robot/catkin_ws/devel Generation path(构建目录) 项修改如下，路径是自己ROS的build目录 /home/robot/catkin_ws/build ","date":"2025-02-05","objectID":"/posts/d8e0057/:3:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"3. wsl+Clion+ros Toolchain选择WSL CMake options： -DCATKIN_DEVEL_PREFIX=/home/lwb/bit_ants/devel -DCMAKE_PREFIX_PATH=/home/lwb/bit_ants/devel -DCMAKE_PREFIX_PATH=/opt/ros/noetic -DPYTHON_EXECUTABLE=/usr/bin/python3 /opt/ros/noetic为你安装ros的目录 /home/lwb/bit_ants/deve为你当前项目的catkin目录 /usr/bin/python3使用的python版本 这些环境变量都可以通过catkin_make来获取，可以对比下cmake和catkin_make哪个环境变量不对就添加哪个 Build directory: ../build ","date":"2025-02-05","objectID":"/posts/d8e0057/:4:0","tags":["Clion","ros","linux"],"title":"CLion上使用ros","uri":"/posts/d8e0057/"},{"categories":["技术文档"],"content":"设置开机自启动 ","date":"2025-02-05","objectID":"/posts/12d83fa/:1:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"1. 创建一个启动脚本 cd ~ touch start_joy.sh chmod +x start_joy.sh ","date":"2025-02-05","objectID":"/posts/12d83fa/:2:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"2. 编辑脚本文件 vim start_joy.sh #!/bin/zsh source /opt/ros/noetic/setup.zsh source /home/nv/ants/devel/setup.zsh roslaunch vehicle_rea joy_control.launch ","date":"2025-02-05","objectID":"/posts/12d83fa/:3:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"3. 配置自动启动 创建 ~/.config/autostart 目录（如果它不存在的话） 使用 gnome-terminal 打开一个新的终端窗口并执行上述脚本。编辑 ~/.config/autostart 目录下的 .desktop 文件来实现这一点 mkdir -p ~/.config/autostart 创建一个新的 .desktop 文件，例如 start_joy.desktop vim ~/.config/autostart/start_joy.desktop [Desktop Entry] Type=Application Exec=gnome-terminal -- zsh -c \"~/start_joy.sh; exec zsh\" Hidden=false NoDisplay=false X-GNOME-Autostart-enabled=true Name[en_US]=Start Joy Name=Start Joy Comment[en_US]=Run start_joy.sh on startup Comment=Run start_joy.sh on startup 其中zsh可以替换为bash gnome-terminal可以替换为terminator ","date":"2025-02-05","objectID":"/posts/12d83fa/:4:0","tags":["自启动","脚本","linux"],"title":"设置开机自启动","uri":"/posts/12d83fa/"},{"categories":["技术文档"],"content":"升级CMake ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:1:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"1. 安装 安装依赖 sudo apt install libssl-dev 去https://cmake.org/files/下载所需版本的源码。也可以使用wget下载，例如： wget https://cmake.org/files/v3.28/cmake-3.28.5.tar.gz tar -xvzf cmake-3.28.5.tar.gz 进入目录配置 cd cmake-3.28.5 chmod 777 ./configure ./configure make -j8 sudo make install ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:2:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"2. 替换 最后使用新安装的cmake替换旧版本，其中/usr/local/bin/cmake为新安装的cmake目录 sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 --force ","date":"2025-02-05","objectID":"/posts/84260000000000000000000000/:3:0","tags":["Cmake","升级"],"title":"升级Cmake","uri":"/posts/84260000000000000000000000/"},{"categories":["技术文档"],"content":"vscode+clang 优势：代码提示更快；可以进行静态分析 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:1:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"1. 在ubuntu上安装clang（推荐14及以上，有类型提示） wget https://apt.llvm.org/llvm.sh chmod u+x llvm.sh sudo ./llvm.sh 14 或者使用清华源 # 下载脚本 wget https://mirrors.tuna.tsinghua.edu.cn/llvm-apt/llvm.sh chmod +x llvm.sh sudo ./llvm.sh 14 all -m https://mirrors.tuna.tsinghua.edu.cn/llvm-apt 将clang14和clang++14设为默认版本 sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-14 200 sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 200 # 列出已存在的替代项 sudo update-alternatives --display clang++ ","date":"2025-02-05","objectID":"/posts/51dd9c5/:2:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"2. 在vscode上安装插件 禁用微软c++插件的代码提示功能 方法一：删除vscode中提供的c++插件。 方法二：在setting.json加入\"C_Cpp.intelliSenseEngine\": “disabled”, 下载clangd插件和codelldb插件，codelldb插件在安装时会自动额外下载一个包 安装好后在clangd插件设置中勾选enable code completion，在clangd插件设置Arguments里面添加--compile-commands-dir=${workspaceFolder}/build 和 --header-insertion=never，Path设置为/usr/bin/clangd-14 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:3:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"3. 配置.clang-format 此文件可以帮助代码格式化，放在主目录便可以了，为了让文件能在保存时自动格式化可以在settings.json里面写入\"editor.formatOnSave\": true 如下为我的.clang-format配置 # 基于那个配置文件 BasedOnStyle: google # 访问说明符的偏移(public private) AccessModifierOffset: -4 #缩进宽度 IndentWidth: 4 # 每行字符的限制，0表示没有限制 ColumnLimit: 80 ","date":"2025-02-05","objectID":"/posts/51dd9c5/:4:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"4. 配置.clang-tidy 此文件可以进行代码的静态分析，放在主目录便可以了，借助Cmake的输出文件可以让代码的静态分析更加准确。在CMakeLists.txt里面写入set(CMAKE_EXPORT_COMPILE_COMMANDS ON) 如下为我的clang-tidy配置 --- Checks: '-*, clang-analyzer-core.*, clang-analyzer-cplusplus.*, modernize-redundant-void-arg, modernize-use-bool-literals, modernize-use-equals-default, modernize-use-nullptr, modernize-use-override, google-explicit-constructor, google-readability-casting, readability-braces-around-statements, readability-identifier-naming.ClassCase, readability-identifier-naming.StructCase, readability-identifier-naming.TypedefCase, readability-identifier-naming.EnumCase, readability-non-const-parameter, cert-dcl21-cpp, bugprone-undelegated-constructor, bugprone-macro-parentheses, bugprone-macro-repeated-side-effects, bugprone-forward-declaration-namespace, bugprone-bool-pointer-implicit-conversion, bugprone-misplaced-widening-cast, cppcoreguidelines-narrowing-conversions, misc-unconventional-assign-operator, misc-unused-parameters' WarningsAsErrors: '' HeaderFilterRegex: '' CheckOptions: # 现代化（Modernize） - key: modernize-redundant-void-arg value: 'true' # 检查并移除函数声明中冗余的 void 参数。 - key: modernize-use-bool-literals value: 'true' # 建议使用布尔字面量 true 和 false 代替整数值 0 和 1。 - key: modernize-use-equals-default value: 'true' # 建议在默认构造函数、复制构造函数和赋值运算符中使用 = default，以简化代码。 - key: modernize-use-nullptr value: 'true' # 建议使用 nullptr 代替 NULL 或 0 来表示空指针。 - key: modernize-use-override value: 'true' # 建议在覆盖基类虚函数时使用 override 关键字，以增加代码的清晰性和安全性。 # Google 代码风格（Google） - key: google-explicit-constructor value: 'true' # 检查并建议在单参数构造函数中使用 explicit 关键字，以防止隐式转换。 - key: google-readability-casting value: 'true' # 检查并建议使用 C++ 风格的类型转换（如 static_cast、dynamic_cast、const_cast 和 reinterpret_cast）代替 C 风格的类型转换。 # 可读性（Readability） - key: readability-braces-around-statements value: 'true' # 建议在单行语句周围添加大括号，以提高代码的可读性和一致性。 - key: readability-identifier-naming.ClassCase value: 'CamelCase' # 类名应使用 CamelCase 风格，例如 MyClassName。 - key: readability-identifier-naming.StructCase value: 'CamelCase' # 结构体名应使用 CamelCase 风格，例如 MyStructName。 - key: readability-identifier-naming.TypedefCase value: 'CamelCase' # 类型定义应使用 CamelCase 风格，例如 MyTypeDef。 - key: readability-identifier-naming.EnumCase value: 'CamelCase' # 枚举名应使用 CamelCase 风格，例如 MyEnumName。 - key: readability-non-const-parameter value: 'true' # 检查并标识非 const 参数，以提高代码的可读性和安全性。 # CERT 安全编码标准（CERT） - key: cert-dcl21-cpp value: 'true' # 检查并标识在头文件中不应包含无命名空间的 using 声明和指令，以防止命名空间污染。 # Bug 检测（Bugprone） - key: bugprone-undelegated-constructor value: 'true' # 检查并标识未委托的构造函数，以确保构造函数的正确性。 - key: bugprone-macro-parentheses value: 'true' # 检查并建议在宏定义中使用括号，以防止潜在的错误。 - key: bugprone-macro-repeated-side-effects value: 'true' # 检查并标识宏中重复的副作用，以防止潜在的错误。 - key: bugprone-forward-declaration-namespace value: 'true' # 检查并标识命名空间前向声明的潜在问题。 - key: bugprone-bool-pointer-implicit-conversion value: 'true' # 检查并标识布尔指针的隐式转换，以防止潜在的错误。 - key: bugprone-misplaced-widening-cast value: 'true' # 检查并标识错误的宽化转换，以防止潜在的错误。 # C++ 核心指南（CppCoreGuidelines） - key: cppcoreguidelines-narrowing-conversions value: 'true' # 检查并标识可能导致数据丢失的窄化转换。 # 杂项（Miscellaneous） - key: misc-unconventional-assign-operator value: 'true' # 检查并标识不常见的赋值操作符重载，以确保代码的一致性和可维护性。 - key: misc-unused-parameters value: 'true' # 检测未使用的参数。 ... ","date":"2025-02-05","objectID":"/posts/51dd9c5/:5:0","tags":["vscode","clang","linux"],"title":"Vscode+clang","uri":"/posts/51dd9c5/"},{"categories":["技术文档"],"content":"升级gcc/g++ ","date":"2025-02-04","objectID":"/posts/4e49678/:1:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"1. 查看版本 gcc -v g++ -v ","date":"2025-02-04","objectID":"/posts/4e49678/:2:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"2. 下载指定版本 进入清华源下载相应版本 https://mirror.tuna.tsinghua.edu.cn/gnu/gcc wget https://mirror.tuna.tsinghua.edu.cn/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.gz 解压文件进入目录,我下载的是gcc-14.1.0,版本因人而异 tar -xf gcc-14.1.0.tar.gz cd gcc-14.1.0 下载依赖包 ./contrib/download_prerequisites 创建一个用于编译GCC的目录： mkdir build \u0026\u0026 cd build 配置编译选项： ../configure --prefix=/opt/gcc-14.1.0 --enable-languages=c,c++ --disable-multilib 开始编译 make -j8 最后，安装GCC： sudo make install ","date":"2025-02-04","objectID":"/posts/4e49678/:3:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"3. 设置软链接 查看系统gcc/g++版本 sudo updatedb --prunepaths=\"/mnt\" locate g++|grep /usr/bin/ locate gcc|grep /usr/bin/ 设置软链接的优先级 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 10 sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-14.1.0/bin/gcc 20 sudo update-alternatives --install /usr/bin/g++ g++ /opt/gcc-14.1.0/bin/g++ 20 手动切换gcc与g++版本 sudo update-alternatives --config gcc sudo update-alternatives --config g++ ","date":"2025-02-04","objectID":"/posts/4e49678/:4:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"},{"categories":["技术文档"],"content":"4. 更新系统libstdc++版本 libstdc++是适应于g++的标准库,位于/usr/lib/x86_64-linux-gnu/下面 使用指令先看下系统目前都有哪些版本的 strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX 寻找安装高版本gcc目录下的libstdc++.so.6 sudo find /opt -name \"libstdc++.so.6*\" 使用之前的指令看看其是否包含需要的版本 strings /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 | grep GLIBCXX 将文件复制到指定目录并建立新的链接 # 复制 sudo cp /opt/gcc-14.1.0/lib64/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/ # 删除之前链接 sudo unlink /usr/lib/x86_64-linux-gnu/libstdc++.so.6 # 创建新的链接 sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.33 /usr/lib/x86_64-linux-gnu/libstdc++.so.6 ","date":"2025-02-04","objectID":"/posts/4e49678/:5:0","tags":["gcc","g++","linux","升级"],"title":"升级GCC","uri":"/posts/4e49678/"}]